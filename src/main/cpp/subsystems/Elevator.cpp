// RobotBuilder Version: 5.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

// ROBOTBUILDER TYPE: Subsystem.

#include <iostream>
#include "subsystems/Elevator.h"
#include <frc/smartdashboard/SmartDashboard.h>

#include "RobotContainer.h"

Elevator::Elevator()
{
    SetName("Elevator");
    SetSubsystem("Elevator");

    m_elevatorMotorA = new rev::CANSparkMax(k_elevatorMotorA, rev::CANSparkMaxLowLevel::MotorType::kBrushless);
    m_elevatorMotorB = new rev::CANSparkMax(k_elevatorMotorB, rev::CANSparkMaxLowLevel::MotorType::kBrushless);
    m_endEffectorMotor = new rev::CANSparkMax(k_endofactorMotor, rev::CANSparkMaxLowLevel::MotorType::kBrushless);
    m_elevatorMotorA->SetInverted(true);
    m_elevatorMotorB->SetInverted(true);
    m_endEffectorMotor->SetInverted(true);
    m_elevatorMotorA->SetIdleMode(rev::CANSparkMax::IdleMode::kBrake);
    m_elevatorMotorB->SetIdleMode(rev::CANSparkMax::IdleMode::kBrake);
    m_elevatorEncoderA = new rev::SparkMaxRelativeEncoder(m_elevatorMotorA->GetEncoder());
    m_elevatorEncoderB = new rev::SparkMaxRelativeEncoder(m_elevatorMotorB->GetEncoder());

    m_compressor = new frc::Compressor(k_pneumaticHub, frc::PneumaticsModuleType::REVPH);
    m_pneumaticHub.EnableCompressorAnalog(units::pressure::pounds_per_square_inch_t(90), 
                                          units::pressure::pounds_per_square_inch_t(120));

    m_elevatorPID = new frc2::PIDController(k_P, k_I, k_D);

    m_elevatorFunction = Elevator_Off;
    m_elevatorPosition = 0.0;
    m_elevatorHomePosition = 0.0;
    m_elevatorTarget = 0.0;
    m_isStowing = false;
    m_targetSet = false;

    // May or may not use this
    m_distancePerRotation = (k_numOfTeeth * k_teethSize) /k_gearRatio;
}

void Elevator::setTopConeTarget()
{
    m_elevatorTarget = k_elevatorTargetTopCone;
    m_targetSet = true;
}

void Elevator::setMidConeTarget()
{
    m_elevatorTarget = k_elevatorTargetMiddleCone;
    m_targetSet = true;
}

void Elevator::setTopCubeTarget()
{
    m_elevatorTarget = k_elevatorTargetTopCube;
    m_targetSet = true;
}

void Elevator::setMidCubeTarget()
{
    m_elevatorTarget = k_elevatorTargetMiddleCube;
    m_targetSet = true;
}

void Elevator::setHumanStationTarget()
{
    m_elevatorTarget = k_elevatorHumanStation;
    m_targetSet = true;
}

void Elevator::resetTarget()
{
    m_elevatorTarget = m_elevatorHomePosition;
    m_targetSet = false;
}

bool Elevator::isElevatorAtHome() 
{
    if(m_elevatorAtHomeLimitSwitch.Get()) 
    {
        return true;
    }

    return false;
}

double Elevator::getElevatorPosition() 
{
    // Get the number of rotation of the motor
    double numOfRotationA = m_elevatorEncoderA->GetPosition();

    return (m_distancePerRotation * numOfRotationA);
}

// TESTING
void Elevator::setElevator(double speed) 
{
    bool overrideLimit = m_operatorJoystick->GetRightBumper();

    if(!overrideLimit)
    {
        if (m_elevatorPosition >= k_maxElevatorPosition) {
            // CASE: at max height - only allow retracting elevator
            speed = speed > 0 ? 0 : speed;
        } else if (m_elevatorPosition <= 0) {
            // CASE: at min height - only allow extending elevator
            speed = speed < 0 ? 0 : speed;
        }
    }

    m_elevatorMotorA->Set(speed);
    m_elevatorMotorB->Set(speed);

    // std::cout << "ElevPosition: " << m_elevatorPosition << "    ElevSpeed: " << speed << "   Cone? " << m_isCone << std::endl;
    // std::cout << "Pos: " << m_elevatorPosition << "   Target: " << m_elevatorTarget << "  ElevSpeed: " << speed << "   State: " << m_elevatorFunction << std::endl;

}

// Put code here to be run every loop
void Elevator::Periodic() 
{ 
    m_elevatorPosition = getElevatorPosition();
    // if(isElevatorAtHome())
    // {
    //     m_elevatorEncoderA->SetPosition(0.0);
    //     m_elevatorEncoderB->SetPosition(0.0);
    //     m_elevatorHomePosition = m_elevatorHomePosition;
    // }

    // TESTING - switch between cone and cube
    // if (m_operatorJoystick->GetRightBumper()) {
    //     m_isCone = m_isCone ? false : true;
    //     std::cout << "set m_isCone: " << m_isCone << std::endl;
    // }

    m_isCone = true;

    // TESTING - simple stow elevator (for testing purposes)
    if (m_operatorJoystick->GetYButton()) 
    {
        stowElevator();
    }

    // TESTING - testing pnuematics (d-pad UP)
    if (m_operatorJoystick->GetPOV() == 0) 
    {
        moveEndEffector(true);
    } 

    // TESTING - testing pnuematics (d-pad DOWN)
    if (m_operatorJoystick->GetPOV() == 180) 
    {
        MoveGrabber(true);
    }       

    // Set zero position (temporary for testing)
    if(m_operatorJoystick->GetStartButton())
    {
        m_elevatorEncoderA->SetPosition(0.0);
        m_elevatorEncoderB->SetPosition(0.0);
        // TESTING - manually set target to 0 when resetting position
        m_elevatorTarget = 0.0;
    }
    // Set scoring object based on the sensor
    // if(m_detectConeLimitSwitch.Get())
    // {
    //     m_isCone = true;
    // }


    // Testing compressor
    // bool status = m_compressor->Enabled();
    // units::pressure::pounds_per_square_inch_t press = m_compressor->GetPressure();
    // std::cout << "Comp Status: " << status << "  Comp Press: " << press << std::endl;
}    

void Elevator::Initialize() 
{
    m_elevatorEncoderA->SetPosition(0.0);
    m_elevatorEncoderB->SetPosition(0.0);
    m_operatorJoystick = RobotContainer::GetInstance()->getOperator();
}

// This method will be called once per scheduler run when in simulation
void Elevator::SimulationPeriodic() {}

double Elevator::getPIDSpeed(double pidCommand)
{
    // Convert PID output to speed command between -1.0 to 1.0
    double speedOut = 0;

    speedOut = pidCommand / 20.0;    // temporary place holder

    if(k_maxElevatorSpeed <= speedOut)
    {
        speedOut = k_maxElevatorSpeed;
    }
    else if(-k_maxElevatorSpeed >= speedOut)
    {
        speedOut = -k_maxElevatorSpeed;
    }

    return speedOut;
}

void Elevator::runElevator() 
{
    //////////////  Routine ELEVATOR FUNCTIONS  /////////////////////
    double elevatorSpeedCmd = 0.0;
    bool elevatorOverride = m_operatorJoystick->GetLeftBumper();
    

    if(elevatorOverride) 
    {
        // Manual operation
        m_elevatorFunction = Elevator_Off;
        m_elevatorStowState = Stow_Off;
        elevatorSpeedCmd = m_operatorJoystick->GetRightY();
        if(k_jsDeadband > std::fabs(elevatorSpeedCmd))
        {
            elevatorSpeedCmd = 0.0;
        }

        setElevator(-0.2 * elevatorSpeedCmd);
    } 
    else 
    {
        // Get the target command
        if(m_operatorJoystick->GetAButtonPressed()) 
        {
            if(m_isCone) 
            {
                setTopConeTarget();
            } 
            else 
            {
                setTopCubeTarget();
            }
            m_elevatorFunction = Elevator_Deploy;
        } 
        else if(m_operatorJoystick->GetBButtonPressed()) 
        {
            if(m_isCone) 
            {
                setMidConeTarget();
            } 
            else 
            {
                setMidCubeTarget();
            }
            m_elevatorFunction = Elevator_Deploy;
        } 
        else if(m_operatorJoystick->GetXButtonPressed()) 
        {
            setHumanStationTarget();
            m_elevatorFunction = Elevator_Deploy;
        } 

        // Set the elevator function based on Joystick command
        switch(m_elevatorFunction) 
        {
            case Elevator_Off:
            default:
                break;

            case Elevator_Deploy:
                if(moveToCurrentTarget())
                {
                    m_elevatorFunction = Elevator_Hold;
                }
                break;
            case Elevator_Hold:
                setElevator(k_elevatorHoldSpeed);
                break;
        }
    }
    
    // endEffector operation
    runEndEffector();
}

bool Elevator::moveToCurrentTarget()
{
    double speedCmd = 0.0;
    bool retVal = false;
    static double lastSpeedCmd = 0.0;

    double pidOut = getPIDSpeed(m_elevatorPID->Calculate(m_elevatorPosition, m_elevatorTarget));

    double delta = std::fabs(m_elevatorTarget - m_elevatorPosition);
    if(k_delta < delta)
    {
        if(pidOut > 0.0)
        {
            if (lastSpeedCmd < 0.0)
                lastSpeedCmd = 0.0;

            if(lastSpeedCmd < pidOut)
            {
                lastSpeedCmd += k_rampPerLoop;
            }
        }
        else if(pidOut < 0.0)
        {
            if (lastSpeedCmd > 0.0)
                lastSpeedCmd = 0.0;

            if(lastSpeedCmd > pidOut)
            {
                lastSpeedCmd -= k_rampPerLoop;
            }
        }
        speedCmd = lastSpeedCmd;
    }
    else
    {
        lastSpeedCmd = 0.0;
        retVal = true;
    }

    setElevator(speedCmd);

    return retVal;
}


bool Elevator::moveElevatorToTargetManual(double target)
{
    bool retVal = false;
    double speedCmd = 0.0;
    const double k_manualElevatorCmd = 0.075; 
    double delta = std::fabs(target - m_elevatorPosition);

    if(k_delta < delta)
    {
        // Move the Elevator
        if(target > m_elevatorPosition)
        {
            // Need to extend the elevator
            speedCmd = k_manualElevatorCmd;
        }
        else if(target < m_elevatorPosition)
        {
            // Need to retract the elevator
            speedCmd = -k_manualElevatorCmd;
        }
    }
    else
    {
        // Target reached
        retVal = true;
    }

    setElevator(speedCmd);

    return retVal;
}

//////////////// endEffector operation ////////////////////

void Elevator::setEndEffectorRoller(double speed) 
{
    m_endEffectorMotor->Set(speed);
}

void Elevator::moveEndEffector(bool down)
{
    m_endEffectorSolenoid.Set(down);
}

void Elevator::MoveGrabber(bool open)
{
    m_endEffectorGrabberSolenoid.Set(open);
}

void Elevator::runEndEffector() 
{
    int endEffectorCmd = m_operatorJoystick->GetPOV();
    switch(m_endEffectorFunction)    
    {
        case EF_Up:
        default:
            // EndEffectorUp, turn off the output
            // std::cout << "end effector - UP" << std::endl;
            moveEndEffector(false);

            // EndEffector can go down only if the Elevator is above Human Station level
            if((180 == endEffectorCmd) && (k_elevatorHumanStation < m_elevatorPosition))
            {
                m_endEffectorFunction = EF_Down;
            }
            break;
        case EF_Down:
            // EndEffector Down, turn on the output
            moveEndEffector(true);
            // std::cout << "end effector - DOWN" << std::endl;

            if((0 == endEffectorCmd) || (k_elevatorHumanStation > m_elevatorPosition))
            {
                m_endEffectorFunction = EF_Up;
            }
            break;
    }

    // #ifdef _TESTELEVATOR
    // std::cout << "EFCmd: " << endEffectorCmd << "; Function: " << m_endEffectorFunction << std::endl;
    // #endif

    /////////////// End Effector Operation ///////////////////

    double endEffectorRollerCmd = m_operatorJoystick->GetLeftY();

    if(k_jsDeadband > std::fabs(endEffectorRollerCmd)) 
    {
        endEffectorRollerCmd = 0;
    } 

    setEndEffectorRoller(endEffectorRollerCmd * k_endEffectorSpeedFactor);
 
    ///////////////////// End Effector Grabber Operations ///////////////////////

    if(0.5 < m_operatorJoystick->GetLeftTriggerAxis())
    {
        MoveGrabber(true);
    }
    else
    {
        MoveGrabber(false);
    }
}


//////////////////  STOW ELEVATOR  /////////////////////////////////
bool Elevator::stowElevator()
{
    m_elevatorFunction = Elevator_Off;
    if(m_operatorJoystick->GetYButton())
    {
        return (moveElevatorToTargetManual(m_elevatorHomePosition));
    }
    else
    {
        return true;
    }


    // switch (m_elevatorStowState)
    // {
    //     case Stow_Off:
    //         // Set target to Elevator Home Position
    //         m_elevatorTarget = m_elevatorHomePosition;
    //         moveEndEffector(false);
    //         m_elevatorStowState = Stow_EndEffectorUp;
    //         break;
    //     case Stow_EndEffectorUp:
    //         break;
    //     case Stow_RetractElevator:
    //         break;
    //     case Stow_Finish:
    //         break;    
    //     default:
    //      break;
    // }

    // return stowed;
}

bool Elevator::stowElevatorAuto()
{
     return (moveElevatorToTargetManual(m_elevatorHomePosition));
}