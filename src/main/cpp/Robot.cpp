// RobotBuilder Version: 4.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

// ROBOTBUILDER TYPE: Robot.

#include "Robot.h"
#include "Globals.h"
#include <frc/smartdashboard/SmartDashboard.h>
#include <frc2/command/CommandScheduler.h>
#include <iostream>
#include <fstream>
#include <cameraserver/CameraServer.h>
#include <cstdio>
#include <iomanip>
#include <ctime>

void Robot::RobotInit() {
  m_container = RobotContainer::GetInstance();
  m_container->m_elevator.Initialize();
  m_container->m_swerveDrive.DrivePods(0.0, 0.0, 0.0, nullptr);

  m_container->m_swerveDrive.SetVoltageCompensation();
  m_container->m_endEffector.Initialize();

  // Get the USB camera from CameraServer
  // cs::UsbCamera camera = frc::CameraServer::StartAutomaticCapture();
  // camera.SetResolution(640,480);
}

/**
 * This function is called every robot packet, no matter the mode. Use
 * this for items like diagnostics that you want to run during disabled,
 * autonomous, teleoperated and test.
 *
 * <p> This runs after the mode specific periodic functions, but before
 * LiveWindow and SmartDashboard integrated updating.
 */
void Robot::RobotPeriodic() 
{ 
  frc2::CommandScheduler::GetInstance().Run(); 

  // SET pod offset angles with values from dashboard
  double leftOffset = frc::SmartDashboard::GetNumber("Left Offset", 404.0);
  double rightOffset = frc::SmartDashboard::GetNumber("Right Offset", 404.0);
  double pointOffset = frc::SmartDashboard::GetNumber("Point Offset", 404.0);
  m_container->m_swerveDrive.SetLeftPodOffsetAngle(leftOffset);
  m_container->m_swerveDrive.SetRightPodOffsetAngle(rightOffset);
  m_container->m_swerveDrive.SetPointPodOffsetAngle(pointOffset);

  m_container->m_elevator.updateValues();

  // SET p_PID values from the dashboard
  double pLeft = frc::SmartDashboard::GetNumber("Left p_PID", 1.0);
  double pRight = frc::SmartDashboard::GetNumber("Right p_PID", 1.0);
  double pPoint = frc::SmartDashboard::GetNumber("Point p_PID", 1.0);
  m_container->m_swerveDrive.SetLeftPodPPID(pLeft);
  m_container->m_swerveDrive.SetRightPodPPID(pRight);
  m_container->m_swerveDrive.SetPointPodPPID(pPoint);

  // SET d_PID values from the dashboard
  double dLeft = frc::SmartDashboard::GetNumber("Left d_PID", 0.0);
  double dRight = frc::SmartDashboard::GetNumber("Right d_PID", 0.0);
  double dPoint = frc::SmartDashboard::GetNumber("Point d_PID", 0.0);
  m_container->m_swerveDrive.SetLeftPodDPID(dLeft);
  m_container->m_swerveDrive.SetRightPodDPID(dRight);
  m_container->m_swerveDrive.SetPointPodDPID(dPoint);

  // SET motor scaling values from the dashboard
  double leftScaling = frc::SmartDashboard::GetNumber("Left Motor Scaling", 0.01);
  double rightScaling = frc::SmartDashboard::GetNumber("Right Motor Scaling", 0.01);
  double pointScaling = frc::SmartDashboard::GetNumber("Point Motor Scaling", 0.01);
  m_container->m_swerveDrive.SetLeftPodPPID(leftScaling);
  m_container->m_swerveDrive.SetRightPodPPID(rightScaling);
  m_container->m_swerveDrive.SetPointPodPPID(pointScaling);

  // SET aligned angle values from the dashboard
  double leftAligned = frc::SmartDashboard::GetNumber("Left Aligned Angle", 404.0);
  double rightAligned = frc::SmartDashboard::GetNumber("Right Aligned Angle", 404.0);
  double pointAligned = frc::SmartDashboard::GetNumber("Point Aligned Angle", 404.0);
  m_container->m_swerveDrive.SetLeftPodPPID(leftAligned);
  m_container->m_swerveDrive.SetRightPodPPID(rightAligned);
  m_container->m_swerveDrive.SetPointPodPPID(pointAligned);

  // SmartDashboard Swerve Drive Motor Temperatures + indicators
  frc::SmartDashboard::PutNumber("Right Top Motor Temp", m_container->m_swerveDrive.GetMotorTemperature(RIGHT_POD, TOP_MOTOR));
  frc::SmartDashboard::PutBoolean("Right Top Temp Indicator", m_container->m_swerveDrive.GetMotorTemperature(RIGHT_POD, TOP_MOTOR) > max_motor_temp);
  frc::SmartDashboard::PutNumber("Right Bottom Motor Temp", m_container->m_swerveDrive.GetMotorTemperature(RIGHT_POD, BOTTOM_MOTOR));
  frc::SmartDashboard::PutBoolean("Right Bottom Temp Indicator", m_container->m_swerveDrive.GetMotorTemperature(RIGHT_POD, BOTTOM_MOTOR) > max_motor_temp);
  frc::SmartDashboard::PutNumber("Left Top Motor Temp", m_container->m_swerveDrive.GetMotorTemperature(LEFT_POD, TOP_MOTOR));
  frc::SmartDashboard::PutBoolean("Left Top Temp Indicator", m_container->m_swerveDrive.GetMotorTemperature(LEFT_POD, TOP_MOTOR) > max_motor_temp);
  frc::SmartDashboard::PutNumber("Left Bottom Motor Temp", m_container->m_swerveDrive.GetMotorTemperature(LEFT_POD, BOTTOM_MOTOR));
  frc::SmartDashboard::PutBoolean("Left Bottom Temp Indicator", m_container->m_swerveDrive.GetMotorTemperature(LEFT_POD, BOTTOM_MOTOR) > max_motor_temp);
  frc::SmartDashboard::PutNumber("Point Top Motor Temp", m_container->m_swerveDrive.GetMotorTemperature(POINT_POD, TOP_MOTOR));
  frc::SmartDashboard::PutBoolean("Point Top Temp Indicator", m_container->m_swerveDrive.GetMotorTemperature(POINT_POD, TOP_MOTOR) > max_motor_temp);
  frc::SmartDashboard::PutNumber("Point Bottom Motor Temp", m_container->m_swerveDrive.GetMotorTemperature(POINT_POD, BOTTOM_MOTOR));
  frc::SmartDashboard::PutBoolean("Point Bottom Temp Indicator", m_container->m_swerveDrive.GetMotorTemperature(POINT_POD, BOTTOM_MOTOR) > max_motor_temp);

  // SmartDashboard Swerve Drive Test Motor Speeds
  frc::SmartDashboard::PutNumber("Test Motor Speed", m_diagnosticSpeed);
}

/**
 * This function is called once each time the robot enters Disabled mode. You
 * can use it to reset any subsystem information you want to clear when the
 * robot is disabled.
 */
void Robot::DisabledInit() {}

void Robot::DisabledPeriodic() {}

/**
 * This autonomous runs the autonomous command selected by your {@link
 * RobotContainer} class.
 */
void Robot::AutonomousInit() {
  m_autonomousCommand = m_container->GetAutonomousCommand();

  if (m_autonomousCommand != nullptr) {
    m_autonomousCommand->Schedule();
  }
}

void Robot::AutonomousPeriodic() {

}

void Robot::TeleopInit() {
  // This makes sure that the autonomous stops running when
  // teleop starts running. If you want the autonomous to
  // continue until interrupted by another command, remove
  // this line or comment it out.
  if (m_autonomousCommand != nullptr) {
    m_autonomousCommand->Cancel();
    m_autonomousCommand = nullptr;
  }
  // auto t = std::time(nullptr);
  // auto tm = *std::localtime(&t);
  // auto filepath = "/home/lvuser/swerve-" + std::put_time(&tm, "%d-%m-%Y %H-%M-%S").str() + ".txt";
  // auto time = std::chrono::system_clock::now();
  // std::time_t t = std::chrono::system_clock::to_time_t(time);
  // std::string ts = std::ctime(&t);
  // ts.resize(ts.size()-1);
  // auto timetypingpls = &ts;
  
  // std::string filepath = "/home/lvuser/swerve-" + std::rand(995298) + ".txt";
  // std::string filepath = "/home/lvuser/swerve-";
  // strcat(filepath, std::rand());
  // strcat(filepath, ".txt");
  // char* filepathfrtho = const_cast<char*>(filepath.c_str());
  // fileOut = fopen(filepathfrtho, "a");
  fileOut = fopen("/home/lvuser/swerve-test.txt", "a");
}

double Joystick(double input, double deadzone) 
{ 
  return (std::fabs(input) < deadzone) ? 0 : input; 
}

/**
 * This function is called periodically during operator control.
 */
void Robot::TeleopPeriodic() 
{  
  // updates pod angle offsets (on dashboard)
  m_container->m_swerveDrive.UpdatePodOffsetAngles();
  // updates pod p_PID vals (on dashboard)
  m_container->m_swerveDrive.UpdatePodPPID();
  // updates pod d_PID vals (on dashboard)
  m_container->m_swerveDrive.UpdatePodDPID();
  // updates pod motor scaling vals (on dashboard)
  m_container->m_swerveDrive.UpdatePodMotorScaling();
  // updates pod aligned angles vals (on dashboard)
  m_container->m_swerveDrive.UpdatePodAlignedAngle();

  // Controller Inputs - Driver Operations
  double targetJoystickLX = Joystick(m_container->getDriver()->GetLeftX(), k_jsDeadband);
  double targetJoystickLY = Joystick(m_container->getDriver()->GetLeftY(), k_jsDeadband);
  double targetJoystickRX = Joystick(m_container->getDriver()->GetRightX(), k_jsDeadband);
  frc::SmartDashboard::PutNumber("LX", targetJoystickLX);
  frc::SmartDashboard::PutNumber("LY", targetJoystickLY);
  frc::SmartDashboard::PutNumber("RX", targetJoystickRX);
  // Initial Swerve State
  bool initialSwerveState = m_container->getDriver()->GetStartButton();
  // Lock Swerve State
  bool lockSwerve = m_container->getDriver()->GetYButton();
  // Swerve Diagnostics State
  bool testRightPod = m_container->getDriver()->GetBButton();
  bool testLeftPod = m_container->getDriver()->GetXButton();
  bool testPointPod = m_container->getDriver()->GetAButton();
  int dPadValue = m_container->getDriver()->GetPOV();

  // When D-Pad is pressed, print if pods are reversed
  if (dPadValue != m_dPadValueLastFrame && dPadValue != -1)
  {
    std::cout << "Left Pod Reversed: " << m_container->m_swerveDrive.GetLeftPodReversed() << std::endl;
    std::cout << "Right Pod Reversed: " << m_container->m_swerveDrive.GetRightPodReversed() << std::endl;
    std::cout << "Point Pod Reversed: " << m_container->m_swerveDrive.GetPointPodReversed() << std::endl;
  }
  m_dPadValueLastFrame = dPadValue;

  std::string driveCase = "NONE";

  if (!lockSwerve) 
  {
    if (
      std::fabs(targetJoystickLX) > k_jsDeadband ||
      std::fabs(targetJoystickLY) > k_jsDeadband ||
      std::fabs(targetJoystickRX) > k_jsDeadband
    ) 
    {
      // joystick inputs for swerve - NO scaling / ramp
      driveCase = "Drive No Scaling";
      double PP[6];
      m_container->m_swerveDrive.DrivePods(targetJoystickLX, targetJoystickLY, targetJoystickRX, PP);
      for (int i = 0; i < 6; i++) {
        fputs(std::to_string(PP[i]).c_str(), fileOut);
        fputs(" ", fileOut);
        // std::cout << std::to_string(PP[i]).c_str() << " " << std::endl;
      }
      fputs("\n", fileOut);
      // std::cout << std::endl;
    }
    else if (initialSwerveState) 
    {
      // Initial Swerve State
      driveCase = "Initial state";
      m_container->m_swerveDrive.InitialSwerve();
    }
    else if ((testRightPod || testLeftPod || testPointPod) && (dPadValue == 0 || dPadValue == 180))
    {
      driveCase = "Pod diagnostic";
      std::string podInput;
      std::string motorInput; 
      podInput = testRightPod ? "RIGHT" : podInput;
      podInput = testLeftPod ? "LEFT" : podInput;
      podInput = testPointPod ? "POINT" : podInput;
      motorInput = dPadValue == 0 ? "TOP" : motorInput; 
      motorInput = dPadValue == 180 ? "BOTTOM" : motorInput;

      // set motors for testing
      m_container->m_swerveDrive.DiagonosticSwerveRotate(podInput, motorInput, 0.6);
    } else if ((!testRightPod && !testLeftPod && !testPointPod) && (dPadValue == 0 || dPadValue == 90 || dPadValue == 180 || dPadValue == 270)) {
      // TESTING FOR SWERVE ANGLE OFFSETS
      driveCase = "dpad offset testing";
      if (dPadValue == 0)
      {
        // forward
        m_container->m_swerveDrive.DrivePods(0.0, 0.2, 0.0, nullptr);
      } else if (dPadValue == 180)
      {
        // backward
        m_container->m_swerveDrive.DrivePods(0.0, -0.2, 0.0, nullptr);
      } else if (dPadValue == 90) {
        // right
        m_container->m_swerveDrive.DrivePods(0.2, 0.0, 0.0, nullptr);
      } else if (dPadValue == 270) {
        // left
        m_container->m_swerveDrive.DrivePods(-0.2, 0.0, 0.0, nullptr);
      }
    }
    else {
      driveCase = "STOPPED";
      m_container->m_swerveDrive.DrivePods(0,0,0,nullptr);
    }

  } 
  else 
  {
    // lock swerve state
    driveCase = "lock state";
    m_container->m_swerveDrive.LockSwerve();
  }
  // std::cout << "CASE: " << driveCase << "  LX: " << targetJoystickLX << "     " << "LY: " << targetJoystickLY << "     " << "RX: " << targetJoystickRX << std::endl;
  
  
  // Elevator Operations
  m_container->m_elevator.runElevator();

  frc::SmartDashboard::PutString("Right Pod Case", m_container->m_swerveDrive.GetRightPodCase());
  frc::SmartDashboard::PutString("Left Pod Case", m_container->m_swerveDrive.GetLeftPodCase());
  frc::SmartDashboard::PutString("Point Pod Case", m_container->m_swerveDrive.GetPointPodCase());
  // frc::SmartDashboard::UpdateValues();
}

/**
 * This function is called periodically during test mode.
 */
void Robot::TestPeriodic() {}

#ifndef RUNNING_FRC_TESTS
int main() { return frc::StartRobot<Robot>(); }
#endif
