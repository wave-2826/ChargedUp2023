// RobotBuilder Version: 5.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

// ROBOTBUILDER TYPE: Command.
#include <frc/smartdashboard/SmartDashboard.h>
#include "commands/AutoBalanceSwerve.h"
#include "Globals.h"

static const double k_multiplier = -1.0;

AutoBalanceSwerve::AutoBalanceSwerve(SwerveDrive* swerveDrive)
                      : m_swerveDrive(swerveDrive)
{

    // Use AddRequirements() here to declare subsystem dependencies
    // eg. AddRequirements(m_Subsystem);
    SetName("AutoBalanceSwerve");
    m_balanceState = Balance_Start;

    // Set default gains
    m_pGain = k_pGain;
    m_iGain = k_iGain;
    m_dGain = k_dGain;
    m_pitchTolerence = k_pitchTolerence;
    m_balancePID = new frc2::PIDController(m_pGain, m_iGain, m_dGain);
}

// Called just before this Command runs the first time
void AutoBalanceSwerve::Initialize() {
    m_balanceState = Balance_Start;
    m_isBalanced = false;
    while (!m_swerveDrive->InitialSwerve());
}

void AutoBalanceSwerve::updatePID(double p, double i, double d, double delta)
{
    m_pGain = frc::SmartDashboard::GetNumber("Balance_P", k_pGain);
    m_iGain = frc::SmartDashboard::GetNumber("Balance_I", k_iGain);
    m_dGain = frc::SmartDashboard::GetNumber("Balance_D", k_dGain);
    m_pitchTolerence = frc::SmartDashboard::GetNumber("Balance_Delta", k_pitchTolerence);

    m_balancePID->SetPID(m_pGain, m_iGain, m_dGain);
}

// Called repeatedly when this Command is scheduled to run
void AutoBalanceSwerve::Execute() 
{
    double robotPitch = m_swerveDrive->GetRobotPitch();
    double moveCmd = 0.0;
    double strafeCmd = 0.0;
    double rotCmd = 0.0;

    switch(m_balanceState) 
    {
        case Balance_Start:
            // Get latest from Smart Dash Board
            m_pGain = frc::SmartDashboard::GetNumber("Balance_P", k_pGain);
            m_iGain = frc::SmartDashboard::GetNumber("Balance_I", k_iGain);
            m_dGain = frc::SmartDashboard::GetNumber("Balance_D", k_dGain);
            m_pitchTolerence = frc::SmartDashboard::GetNumber("Balance_Delta", k_pitchTolerence);
            m_balancePID->SetPID(m_pGain, m_iGain, m_dGain);

            // CASE: before charging station ramp drive straight on the other side 
            m_isBalanced = false; 
            moveCmd = k_multiplier * m_balancePID->Calculate(robotPitch, 2.0);        
            if (robotPitch > 2.0) {
                m_balancePID->Reset();
                m_balanceState = Balance_Active;
            }
            std::cout << "BEFORE BALANCE" << std::endl;
            break;
        case Balance_Active:
            m_isBalanced = false;
            // Use PID to get inside pitch tolerence
            if(std::fabs(robotPitch) > m_pitchTolerence)
            {
                m_balanceTimer = 0;
                double pidOut = m_balancePID->Calculate(robotPitch, 0.0);
                moveCmd = k_multiplier * pidOut;

                std::cout << "PID Out: " << pidOut << std::endl;
            }
            else
            {
                m_balanceTimer++;
                if(TWO_SECONDS < m_balanceTimer)
                {
                    m_balanceState = Balance_Success;
                }
            }
            break;
        case Balance_Success:
            // CASE: balanced on station
            m_isBalanced = true;
            std::cout << "LEVEL BALANCE" << std::endl;
            break;
        default:
            break;
    }


    m_swerveDrive->DrivePods(strafeCmd, moveCmd, rotCmd, nullptr);
    std::cout << "State: " << m_balanceState <<" PITCH: " << robotPitch << " Move: " << moveCmd << "FINISHED: " << m_isBalanced << std::endl;
    std::cout << "P: " << m_pGain <<" I: " << m_iGain << " D: " << m_dGain << std::endl;
}

// Make this return true when this Command no longer needs to run execute()
bool AutoBalanceSwerve::IsFinished() {
    if (m_isBalanced) {
        m_swerveDrive->DrivePods(0, 0, 0, nullptr);
    }
    return m_isBalanced;
}

// Called once after isFinished returns true
void AutoBalanceSwerve::End(bool interrupted) {
    m_swerveDrive->DrivePods(0, 0, 0, nullptr);
}

bool AutoBalanceSwerve::RunsWhenDisabled() const {
    return false;

}
